# Assemble a nengo folder suitable for being dropped into a USB memory stick for
# offline installation
# TODO: Make it multi-threaded
# TODO: Make an option to not download into the directory the script is running in?

import os
import urllib, urlparse
import re
import subprocess

from bs4 import BeautifulSoup

# Because I want pretty dict initialization
class Vividict(dict):
    def __missing__(self, key):
        value = self[key] = type(self)()
        return value

# TODO: Figure out how to just get the most recent version and then dynamically
# create the batch file and shell file 
# Use http://repo.continuum.io/anaconda3/ if you want Python3, but for now we're going to use Python2, because I haven't converted the GUI to be Python2 compatible
anaconda_url = "http://repo.continuum.io/archive/"
miniconda_url = "http://repo.continuum.io/miniconda/"
soup = BeautifulSoup(urllib.urlopen(anaconda_url).read())
most_recent_anaconda = re.search(r"[0-9]+\.[0-9]+\.[0-9]+", soup.find_all('a')[-1].text).group(0)
soup = BeautifulSoup(urllib.urlopen(miniconda_url).read())
most_recent_miniconda = re.search(r"[0-9]+\.[0-9]+\.[0-9]+", soup.find_all('a')[-1].text).group(0)

# Where to get the various packages
conda_list = Vividict()
conda_list["os_x"]["64_bit"] = (
    "%sAnaconda-%s-MacOSX-x86_64.pkg" %(anaconda_url, most_recent_aanaconda,),
    "%sMiniconda-%s-MacOSX-x86_64.pkg" %(miniconda_url, most_recent_miniconda,)
    )
conda_list["linux"]["32_bit"] = (
    "%sAnaconda-%s-Linux-x86.sh" %(anaconda_url, most_recent_anaconda,),
    "%sMiniconda-%s-Linux-x86.sh" %(miniconda_url, most_recent_miniconda,)
    )
conda_list["linux"]["64_bit"] = (
    "%sAnaconda-%s-Linux-x86_64.sh" %(anaconda_url, most_recent_anaconda,),
    "%sMiniconda-%s-Linux-x86_64.sh" %(miniconda_url, most_recent_miniconda,)
    )
conda_list["windows"]["32_bit"] = (
    "%sAnaconda-%s-Windows-x86.exe" %(anaconda_url, most_recent_anaconda,),
    "%sMiniconda-%s-Windows-x86.exe" %(miniconda_url, most_recent_miniconda,)
    )
conda_list["windows"]["64_bit"] = (
    "%sAnaconda-%s-Windows-x86_64.exe" %(anaconda_url, most_recent_anaconda,),
    "%sMiniconda-%s-Windows-x86_64.exe" %(miniconda_url, most_recent_miniconda,)
    )


# Make directories and download packages
for op_sys, op_key in conda_list.iteritems():
    for arch, url_list in op_key.iteritems():
        print("%s %s %s" %(op_sys, arch, url_list))
        target_dir = "packages/%s/%s/" %(op_sys, arch,)
        if not os.path.exists(target_dir):
            os.makedirs(target_dir)
        for url in url_list:
            print("downloading %s" %url)
            print("target %s/%s" %(target_dir, urlparse.urlsplit(url).path.split("/")[-1],))
            urllib.urlretrieve(url, "%s/%s" %(target_dir, urlparse.urlsplit(url).path.split("/")[-1],))

# TODO: Download a release instead of the raw source
# Download Nengo and extract into `nengo` folder
urllib.urlretrieve("https://github.com/nengo/nengo/archive/master.zip", "nengo.zip")
subprocess.call(["unzip", "nengo.zip"])
subprocess.call(["mv nengo-master", "nengo")
# Build the docs # TODO: Add offline README indicating where the offline docs are

shell_file_text = """WARNING: This file is automatically generated by make-usb.py

"""

batch__file_text = """WARNING: This file is automatically generated by make-usb.py

"""