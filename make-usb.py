# Assemble a nengo folder suitable for being dropped into a USB memory stick for
# offline installation
# TODO: Make it multi-threaded
# TODO: Make an option to not download into the directory the script is running in?
# TODO: Compile the regexes for better performance

import os
import urllib, urlparse
import re
import subprocess

from bs4 import BeautifulSoup

# TODO: Download a release instead of the raw source
# Download Nengo and extract into `nengo` folder
urllib.urlretrieve("https://github.com/nengo/nengo/archive/master.zip", "nengo.zip")
subprocess.call(["unzip", "nengo.zip"])
subprocess.call(["mv nengo-master", "nengo")

# Because I want pretty dict initialization
class Vividict(dict):
    def __missing__(self, key):
        value = self[key] = type(self)()
        return value

# TODO: Figure out how to just get the most recent version and then dynamically
# create the batch file and shell file 
# Use http://repo.continuum.io/anaconda3/ and "Miniconda3" if you want Python3, but for now we're going to use Python2, because I haven't converted the GUI to be Python2 compatible
anaconda_url = "http://repo.continuum.io/archive/"
miniconda_url = "http://repo.continuum.io/miniconda/"

soup = BeautifulSoup(urllib.urlopen(anaconda_url).read())
most_recent_anaconda = re.search(
    r"[0-9]+\.[0-9]+\.[0-9]+", soup.find_all('a')[-1].text
).group(0)

soup = BeautifulSoup(urllib.urlopen(miniconda_url).read())
most_recent_miniconda = re.search(
    r"[0-9]+\.[0-9]+\.[0-9]+", soup.find_all('a')[-1].text
).group(0)

# Where to get the various condas (could definitly be done more a more DRY manner)
conda_list = Vividict()
conda_list["os_x"]["64_bit"] = (
    "%sAnaconda-%s-MacOSX-x86_64.pkg" %(anaconda_url, most_recent_aanaconda,),
    "%sMiniconda-%s-MacOSX-x86_64.pkg" %(miniconda_url, most_recent_miniconda,)
)
conda_list["linux"]["32_bit"] = (
    "%sAnaconda-%s-Linux-x86.sh" %(anaconda_url, most_recent_anaconda,),
    "%sMiniconda-%s-Linux-x86.sh" %(miniconda_url, most_recent_miniconda,)
)
conda_list["linux"]["64_bit"] = (
    "%sAnaconda-%s-Linux-x86_64.sh" %(anaconda_url, most_recent_anaconda,),
    "%sMiniconda-%s-Linux-x86_64.sh" %(miniconda_url, most_recent_miniconda,)
)
conda_list["windows"]["32_bit"] = (
    "%sAnaconda-%s-Windows-x86.exe" %(anaconda_url, most_recent_anaconda,),
    "%sMiniconda-%s-Windows-x86.exe" %(miniconda_url, most_recent_miniconda,)
)
conda_list["windows"]["64_bit"] = (
    "%sAnaconda-%s-Windows-x86_64.exe" %(anaconda_url, most_recent_anaconda,),
    "%sMiniconda-%s-Windows-x86_64.exe" %(miniconda_url, most_recent_miniconda,)
)

pkg_url_list = Vividict()
pkg_url_list["os_x"]["64_bit"] = (
    "http://repo.continuum.io/pkgs/free/osx-64/"
)
pkg_url_list["linux"]["32_bit"] = (
    "http://repo.continuum.io/pkgs/free/linux-32/"
)
pkg_url_list["linux"]["64_bit"] = (
    "http://repo.continuum.io/pkgs/free/linux-64/"
)
pkg_url_list["windows"]["32_bit"] = (
    "http://repo.continuum.io/pkgs/free/win-32/"
)
pkg_url_list["windows"]["64_bit"] = (
    "http://repo.continuum.io/pkgs/free/win-64/"
)
# populate from requirements.txt, which will only be numpy for now
python_version_list = ["py26", "py27", "py34"]
soup = BeautifulSoup(urllib.urlopen(pkg_url_list["windows"]["64_bit"]).read())

pkg_list = Vividict()
pkg_list["numpy"] = ""
result = ""
newest_vers = ""
for pkg in pkg_list:
    # Get the most recent version of the package assuming that the most recent
    # version is the same accross operating systems
    for link_text in soup.find_all('a').text:
        result = re.search(
            r"%s-[0-9]+\.[0-9]+\.[0-9]+" %(pkg, ), link_text
        ).group(0)
        if(result != ""):
            newest_vers = result
    pkg_list[pkg] = newest_vers


# Make directories and download condas, packages
for op_sys, op_key in conda_list.iteritems():
    for arch, url_list in op_key.iteritems():
        print("%s %s %s" %(op_sys, arch, url_list))
        target_dir = "packages/%s/%s/" %(op_sys, arch,)
        if not os.path.exists(target_dir):
            os.makedirs(target_dir)
        # Download condas
        for url in url_list:
            print("downloading %s" %url)
            print("target %s/%s" %(target_dir, urlparse.urlsplit(url).path.split("/")[-1],))
            urllib.urlretrieve(url, "%s/%s" %(target_dir, urlparse.urlsplit(url).path.split("/")[-1],))
        # Download packages for all major python versions
        for pkg, pkg_vers in pkg_list:
            for py_vers in python_version_list:
                urllib.urlretrieve(
                    "%s%s-%s-%s_0.tar.bz2" %(pkg_url_list[op_sys][arch], pkg, pkg_vers, py_vers),
                    "%s/%s" %(target_dir, urlparse.urlsplit(url).path.split("/")[-1],)
                )


# Download packages 

shell_file_text = """WARNING: This file is automatically generated by make-usb.py

"""

batch__file_text = """WARNING: This file is automatically generated by make-usb.py

"""